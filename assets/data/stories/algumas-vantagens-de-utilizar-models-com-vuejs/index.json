{"hash":"9041abd1c6274815caa93d2f49fb0b7b570170d3","data":null,"context":{"story":{"title":"Algumas vantagens de utilizar models com Vue.js","slug":"algumas-vantagens-de-utilizar-models-com-vuejs","contents":[{"type":"code","language":"javascript","content":"const Story = {\n  \"title\" : \"Algumas vantagens de utilizar models no javascript com Vue.js\"\n}"},{"type":"text","content":"\n        <p>\n        Se você utiliza ou já utilizou <a href=\"https://vuejs.org\" target=\"_blank\">Vue.js</a> em seus projetos provavelmente você já ouviu falar de data bind e reatividade.\n      </p>\n\n      <p>\n        Eu mesmo visitei <a target=\"_blank\" href=\"https://br.vuejs.org/v2/guide/reactivity.html\">esta página da documentação</a>\n        algumas booas vezes sempre que surgia dúvida do que fazer quando a propriedade de \n        algum objeto insistia em não ser tão reativa assim como esperado.\n      </p>\n\n      <p>Pois é, reatividade é a base da maioria dos frameworks modernos e com o Vue.Js não é diferente.\n        Resumindo muito, mas muito mesmo: para que a varinha mágica da reatividade \n        funcione no Vue.js, basicamente ele precisa conhecer os dados de seu objeto e \n        uma das maneiras de fazer isso é declarar a estrutura de seu objeto na \n        propriedade \"data\" de seus componentes:\n      </p>\n      "},{"type":"code","language":"javascript","content":"//VueComponent.vue\nexport default {\n  //...\n  data(){\n    return {\n      user: {\n        name: 'Igor',\n        last_name: 'Trindade',\n        tax_document: '123.456.789-01'\n      }\n    }\n  }\n  //...\n}"},{"type":"text","content":"\n        <p>\n          Conforme sua aplicação vai crescendo e você vai criando cada vez mais \n          componentes você vai precisar replicar a estrutura de seus objetos entre \n          seus componentes.\n        </p>\n\n        <p>\n          É nesta hora que separar a estrutura dos seus Models pode ser muito útil inclusive\n          para facilitar a manutenção de sua aplicação.\n        </p>\n        <p>Isto que estou falando não é nada novo, na verdade é um dos padrões mais difundidos\n          da nossa área: a programação orientada a objetos. \n        </p>\n        <p>\n          Mas o que talvez você ainda não tenha pensado é que você pode aproveitar esse padrão \n          também do lado do frontend e ganhar tempo tornando o desenvolvimento das \n          suas aplicações com Vue e Javascript ainda mais eficaz e organizado.\n        </p>\n        <p>\n          Então chega de enrolação e vamos ao que interessa: o código! \n          Vamos começar criando nossa classe <b>User</b> para utilizarmos em nossos componentes;\n        </p>\n      "},{"type":"code","language":"javascript","content":"//User.js\nexport default class User {\n  constructor(obj = {}) {\n    this.name = obj.name || '';\n    this.last_name = obj.last_name || '';\n    this.tax_document = obj.tax_document || '';\n  }\n}"},{"type":"text","content":"\n        <p>\n          Agora em todo lugar que você precisar utilizar seu \n          objeto <b>user: { ... }</b> você pode apenas criar uma nova instância \n          através do constructor: <b>new User()</b>\n        </p>\n      "},{"type":"code","language":"javascript","content":"//VueComponent.vue\nimport User from '../models/User' //caminho do model\nexport default {\n  //...\n  data(){\n    return {\n      user: new User()\n    }\n  }\n  //..."},{"type":"text","content":"\n      <p>\n        Mas você deve estar se perguntando qual a real vantagem de separar a camada \n        do Model sendo que inicialmente a gente acaba escrevendo mais código, não é mesmo?\n      </p>\n\n      <p>Pois agora começa a parte realmente interessante!</p>\n    \n      <p>\n        Assim como no backend boa parte dos Models possuem métodos de transformação dos dados e\n        criando seus Models também do lado do client(frontend) você também pode utilizar esse e outros benefícios maravilhosos\n        da programação orientada a objetos, por exemplo criando mutations que tratam \n        os atributos das suas classes no retorno do banco ou API's.\n        Ou seja, padronizando a entrada de dados na sua aplicação.\n        Veja um exemplo simples de mutation com data de nascimento;\n      </p>\n      "},{"type":"code","language":"javascript","content":"//User.js\nimport moment from 'moment'\nexport default class User {\n  constructor(obj = {}) {\n    this.name = obj.name || '';\n    this.last_name = obj.last_name || '';\n    this.tax_document = obj.tax_document || '';\n\n    /**\n    * Mutations\n    */\n    this.bday = moment(obj.bday, 'YYYY-MM-DD').format('DD/MM/YYYY') || '';\n}"},{"type":"text","content":"\n        <p>No exemplo acima ao instânciar um objeto da classe User, \n          nós verificamos se a propriedade bday do objeto que recebemos pelo parâmetro \n          no construtor é válida ou true e aplicamos a mutation que irá formatar a data para o formato 'DD/MM/YYYY'.\n          Caso contrário nós passamos uma string vazia para que o atributo tenha a propriedade definida com o \n          valor default que setamos na segundo condição dos operadores lógicos\n        <p>\n          E se você já gostou do que viu, imagine agora implementar uma validação \n          dinânima e personalizada para seus forms podendo criar funções específicas por campo,\n          centralizadas em uma única classe e que poderá ser reutilizada aonde quer que você \n          precise validar uma instância daquele Model?\n        </p>\n\n        <p>Pois bem, veja abaixo o que um Turbo Model pode fazer por você, uma validação reativa direto na classe que mais conhece os dados: o Model:</p>\n      "},{"type":"code","language":"javascript","content":"get requireds(){\n  return [\n    {\n      item: 'tax_document',\n      label: 'cpf válido',\n      validation: (value) => {\n        if (value.length < 14) return true\n\n        let cpf = value.replace(/D/g, '');\n        if(cpf.toString().length != 11 || /^(d)\\1{10}$/.test(cpf)) return true;\n        var result = false;\n        [9,10].forEach(function(j){\n          var soma = 0, r;\n          cpf.split(/(?=)/).splice(0,j).forEach(function(e, i){\n            soma += parseInt(e) * ((j+2)-(i+1));\n          });\n          r = soma % 11;\n          r = (r <2)?0:11-r;\n          if(r != cpf.substring(j, j+1)) result = true;\n        });\n        return result;\n      }\n    }\n  ]\n}\n\nget errors(){\n  return this.requireds.filter((req) => {\n    if(typeof(req.validation) == 'function'){\n      return req.validation(this[req.item])\n    }\n\n    if(typeof(this[req.item]) == 'string' && !this[req.item] || Array.isArray(this[req.item]) && !this[req.item].length ){\n      return req\n    }\n  })\n}\n\nget hasError(){\n  return (this.errors.length) ? true : false\n}\n\nget error_phrases(){\n  return {\n    init: 'Você precisa informar ',\n    end: ' para concluir o cadastro.'\n  }\n}\n\nget validation_phrase(){\n  if(!this.hasError) return 'Uhull, tudo certo! Clique em cadastrar.'\n  return this.error_phrases.init + this.errors.map( (erro) => erro.label).join(', ') + this.error_phrases.end;\n}"}]}}}