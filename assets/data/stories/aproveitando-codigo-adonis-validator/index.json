{"hash":"f2a195599fc92fcf5826a8f89b6557692b4662c2","data":null,"context":{"story":{"slug":"aproveitando-codigo-adonis-validator","title":"Adonis e Validators","description":"Reaproveitando messagens de validação com traits","image":"https://images.pexels.com/photos/761297/pexels-photo-761297.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=650&w=940","contents":[{"type":"code","language":"javascript","content":"const Story = {\n  \"title\" : \"Aprendendo Adonis.js - reaproveitando messagens de validação\"\n}"},{"type":"text","content":"\n        <p>Durante a criação de validators as vezes podemos nos ver repetingo código e como programadores procuramos sempre uma maneira de simplificar e facilitar as coisas, ou seja, repetir menos código abstraindo parte da lógica de nossos componentes e classes.</p>\n        <p>Os validators do Adonis.js utilizam a library de validação Indicative e nós vamos utilizar um pouco da programação orientada a objetos para abstrair e reutilizar parte da lógica de validação dos nossos forms.</p>\n        <p>Para começar, vamos criar nosso validator através do comando: <b>$ adonis make:validator RegisterUser</b> e adicionar algumas regrinhas:</p>\n\n      "},{"type":"code","language":"javascript","content":"'use strict'\n\nconst StandartMessages = require('./StandartMessages')\n\nclass RegisterUser {\n\n  get rules () {\n    return {\n      email: 'required|unique:users,email',\n      password: 'required|min:6|max:20'\n    }\n  }\n\n  get sanitizationRules () {\n    return {\n      email: 'normalize_email'\n    }\n  }\n\n  get messages() {\n    return {\n      \"email.required\" : \"Insira um email válido\",\n      \"password.required\" : \"Insira um password válido\",\n    }\n  }\n\n  async fails(errorMessages) {\n    return this.ctx.response.json({ errors: errorMessages.map((error) => error.message) })\n  }\n\n}\n\nmodule.exports = RegisterUser"},{"type":"text","content":"\n        <p>No nosso validator <b>RegisterUser.js</b> nós validamos os campos <b>email</b> e <b>password</b>.</p>\n        <p>O problema desse approach é que provavelmente vamos precisar reutilizar as mensagens de erro para nossas validações e com isso repetir código em todos os validators.</p>\n        <p>Para contornar esse problema podemos abstrair um pouco os métodos de messages e importamos apenas no módulos de validação que formos utilizar mensagens padrões do sistema, criando um módulo StandartMessges.js que vamos utiliza-lo como uma trait no javascript:</p>\n\n      "},{"type":"code","language":"javascript","content":"//StandartMessages.js\nmodule.exports = {\n\n  get validateAll () {\n    return true\n  },\n\n  get messages() {\n    return {\n      \"min\": \"{{ field }}: mínimo de {{ argument.0 }}\",\n      \"required\" : \"{{ field }}: campo obrigatório\"\n    }\n  },\n\n  async fails(errorMessages) {\n    return this.ctx.response.json({ errors: errorMessages.map((error) => error.message) })\n  }\n\n}"},{"type":"text","content":"\n        <p>E agora para importamos os métodos que definimos na trait acima,  precisamos importar o módulo para a classe RegisterUser através do método <b>Object.assign(RegisterUser.prototype, StandartMessages)</b></p>\n\n      "},{"type":"code","language":"javascript","content":"//RegisterUser.js\n'use strict'\n\nconst StandartMessages = require('./StandartMessages')\n\nclass RegisterUser {\n\n  get rules () {\n    return {\n      email: 'required|unique:users,email',\n      password: 'required|min:6|max:20'\n    }\n  }\n\n  get sanitizationRules () {\n    return {\n      email: 'normalize_email'\n    }\n  }\n\n}\n\nObject.assign(RegisterUser.prototype, StandartMessages)\n\nmodule.exports = RegisterUser"}]}}}